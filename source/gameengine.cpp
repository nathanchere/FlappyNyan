#include <ctime>
#include <nds.h>
#include <string.h>
#include "h/gameengine.h"
#include "h/gamestate.h"

#include "h/global.h"

void GameEngine::Init()
{
	srand(clock());
	videoSetMode(MODE_5_3D);
	videoSetModeSub(MODE_0_2D);	
	vramSetBankI( VRAM_I_SUB_BG_0x06208000 );	
	vramSetBankA( VRAM_A_TEXTURE );
	vramSetBankE(VRAM_E_TEX_PALETTE); 
			 
	consoleSelect(&bottomScreen);
	
	consoleInit( &bottomScreen, 0, BgType_Text4bpp, BgSize_T_256x256, 20, 0, false, false );	
	
	glScreen2D();
		
	// Init console font
	font_console.gfx = (u16*)fontTiles;
	font_console.pal = (u16*)fontPal;
	font_console.numChars = 95;
	font_console.numColors =  fontPalLen / 2;
	font_console.bpp = 4;
	font_console.asciiOffset = 32;
	font_console.convertSingleColor = false;			
	consoleSetFont(&bottomScreen, &font_console);
	
	
	font_small.Load( FontImages,	// pointer to glImage array
		   FONT_8X8_NUM_IMAGES, 	// Texture packer auto-generated #define
		   font_8x8_texcoords,		// Texture packer auto-generated array
		   GL_RGB256,				// texture type for glTexImage2D() in videoGL.h 
		   TEXTURE_SIZE_64,			// sizeX for glTexImage2D() in videoGL.h
		   TEXTURE_SIZE_128,		// sizeY for glTexImage2D() in videoGL.h
		   GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT,
		   256,						// Length of the palette (256 colors)
		   (u16*)font_8x8Pal,		// Palette Data
		   (u8*)font_8x8Bitmap		// image data generated by GRIT 
		 );
}

void GameEngine::ChangeState(GameState* state) 
{
	if ( !states.empty() ) {
		states.back()->Dispose();
		states.pop_back();
	}

	states.push_back(state);
	states.back()->Init();
}

void GameEngine::PushState(GameState* state)
{
	if ( !states.empty() ) {
		states.back()->Pause();
	}

	states.push_back(state);
	states.back()->Init();
}

void GameEngine::PopState()
{
	if ( !states.empty() ) {
		states.back()->Dispose();
		states.pop_back();
	}

	if (!states.empty()) states.back()->Resume();
}


void GameEngine::HandleEvents() 
{
	if (!states.empty()) states.back()->HandleEvents(this);
}

void GameEngine::Update() 
{
	if (!states.empty()) states.back()->Update(this);
}

void GameEngine::Render() 
{
	if (!states.empty()) states.back()->Render(this);
}
